import fs from 'node:fs/promises';
import path from 'node:path';
import crypto from 'node:crypto';

const REPO_ROOT = path.resolve(import.meta.dirname, '..', '..', '..');

export class McpServer {
  async execute(command: string, args: string[]): Promise<unknown> {
    switch (command) {
      case 'getRepoMap':
        return this.getRepoMap();
      case 'getStandards':
        return this.getStandards();
      case 'getKnowledgeBaseIndex':
        return this.getKnowledgeBaseIndex();
      case 'writeADR':
        return this.writeADR(args[0] ?? 'Untitled');
      case 'createSolutionWorkspace':
        return this.createSolutionWorkspace(args[0]);
      default:
        throw new Error(`Unknown command: ${command}`);
    }
  }

  /** Return a flat list of top-level dirs */
  async getRepoMap(): Promise<{ directories: string[] }> {
    const entries = await fs.readdir(REPO_ROOT, { withFileTypes: true });
    const dirs = entries
      .filter((e) => e.isDirectory() && !e.name.startsWith('.') && e.name !== 'node_modules')
      .map((e) => e.name);
    return { directories: dirs };
  }

  /** Read standards documents */
  async getStandards(): Promise<{ files: Record<string, string> }> {
    const files: Record<string, string> = {};
    const stdPaths = [
      'docs/api/conventions.md',
      'docs/api/security-checklist.md',
      'knowledge-base/engineering/coding-standards.md',
      'knowledge-base/engineering/security-standards.md',
      'knowledge-base/engineering/approved-dependencies.md',
      'knowledge-base/engineering/blockchain-standards.md',
    ];
    for (const rel of stdPaths) {
      try {
        files[rel] = await fs.readFile(path.join(REPO_ROOT, rel), 'utf-8');
      } catch {
        files[rel] = '(not found)';
      }
    }
    return { files };
  }

  /** List knowledge-base directory tree */
  async getKnowledgeBaseIndex(): Promise<{ entries: string[] }> {
    const kbRoot = path.join(REPO_ROOT, 'knowledge-base');
    const entries: string[] = [];

    async function walk(dir: string, prefix: string) {
      let items: import('node:fs').Dirent[];
      try {
        items = await fs.readdir(dir, { withFileTypes: true });
      } catch {
        return;
      }
      for (const item of items) {
        const rel = prefix ? `${prefix}/${item.name}` : item.name;
        if (item.isDirectory()) {
          entries.push(rel + '/');
          await walk(path.join(dir, item.name), rel);
        } else {
          entries.push(rel);
        }
      }
    }

    await walk(kbRoot, '');
    return { entries };
  }

  /** Create an ADR from template */
  async writeADR(title: string): Promise<{ path: string }> {
    const id = crypto.randomUUID().slice(0, 8);
    const dir = path.join(REPO_ROOT, 'docs', 'architecture', 'decisions');
    await fs.mkdir(dir, { recursive: true });
    const filename = `ADR-${id}.md`;
    const content = [
      `# ADR-${id}: ${title}`,
      '',
      '## Status',
      'Proposed',
      '',
      '## Context',
      '<!-- Describe the context -->',
      '',
      '## Decision',
      '<!-- Describe the decision -->',
      '',
      '## Consequences',
      '<!-- Describe consequences -->',
      '',
    ].join('\n');
    const filePath = path.join(dir, filename);
    await fs.writeFile(filePath, content, 'utf-8');
    return { path: `docs/architecture/decisions/${filename}` };
  }

  /** Scaffold a solution workspace */
  async createSolutionWorkspace(requestId?: string): Promise<{ path: string }> {
    const id = requestId ?? crypto.randomUUID().slice(0, 8);
    const dir = path.join(REPO_ROOT, 'solutions', '_staging', id);
    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(
      path.join(dir, 'README.md'),
      `# Solution Workspace\n\nRequest ID: ${id}\n\nGenerated by MCP Server.\n`,
      'utf-8',
    );
    return { path: `solutions/_staging/${id}` };
  }
}
